(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{0:function(e,t,n){"use strict";var a=function(e,t,n,a){return new(n||(n=Promise))((function(o,i){function r(e){try{c(a.next(e))}catch(e){i(e)}}function s(e){try{c(a.throw(e))}catch(e){i(e)}}function c(e){var t;e.done?o(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(r,s)}c((a=a.apply(e,t||[])).next())}))};let o=void 0;t.a=function(){return a(this,void 0,void 0,(function*(){if(void 0!==o)return o;const e=yield import("https://unpkg.com/@webgpu/glslang@0.0.15/dist/web-devel/glslang.js");return o=yield e.default(),o}))}},21:function(e,t,n){"use strict";n.r(t),n.d(t,"title",(function(){return i})),n.d(t,"description",(function(){return r})),n.d(t,"init",(function(){return s}));var a=n(0),o=function(e,t,n,a){return new(n||(n=Promise))((function(o,i){function r(e){try{c(a.next(e))}catch(e){i(e)}}function s(e){try{c(a.throw(e))}catch(e){i(e)}}function c(e){var t;e.done?o(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(r,s)}c((a=a.apply(e,t||[])).next())}))};const i="Compute Boids",r="A GPU compute particle simulation that mimics                             the flocking behavior of birds. A compute shader updates                             two ping-pong buffers which store particle data. The data                             is used to draw instanced particles.";function s(e){return o(this,void 0,void 0,(function*(){const t="#version 450\n  layout(location = 0) in vec2 a_particlePos;\n  layout(location = 1) in vec2 a_particleVel;\n  layout(location = 2) in vec2 a_pos;\n  void main() {\n    float angle = -atan(a_particleVel.x, a_particleVel.y);\n    vec2 pos = vec2(a_pos.x * cos(angle) - a_pos.y * sin(angle),\n            a_pos.x * sin(angle) + a_pos.y * cos(angle));\n    gl_Position = vec4(pos + a_particlePos, 0, 1);\n  }",n="#version 450\n  layout(location = 0) out vec4 fragColor;\n  void main() {\n    fragColor = vec4(1.0);\n  }",o="#version 450\n  struct Particle {\n    vec2 pos;\n    vec2 vel;\n  };\n\n  layout(std140, set = 0, binding = 0) uniform SimParams {\n    float deltaT;\n    float rule1Distance;\n    float rule2Distance;\n    float rule3Distance;\n    float rule1Scale;\n    float rule2Scale;\n    float rule3Scale;\n  } params;\n\n  layout(std140, set = 0, binding = 1) buffer ParticlesA {\n    Particle particles[1500];\n  } particlesA;\n\n  layout(std140, set = 0, binding = 2) buffer ParticlesB {\n    Particle particles[1500];\n  } particlesB;\n\n  void main() {\n    // https://github.com/austinEng/Project6-Vulkan-Flocking/blob/master/data/shaders/computeparticles/particle.comp\n\n    uint index = gl_GlobalInvocationID.x;\n    if (index >= 1500) { return; }\n\n    vec2 vPos = particlesA.particles[index].pos;\n    vec2 vVel = particlesA.particles[index].vel;\n\n    vec2 cMass = vec2(0.0, 0.0);\n    vec2 cVel = vec2(0.0, 0.0);\n    vec2 colVel = vec2(0.0, 0.0);\n    int cMassCount = 0;\n    int cVelCount = 0;\n\n    vec2 pos;\n    vec2 vel;\n    for (int i = 0; i < 1500; ++i) {\n      if (i == index) { continue; }\n      pos = particlesA.particles[i].pos.xy;\n      vel = particlesA.particles[i].vel.xy;\n\n      if (distance(pos, vPos) < params.rule1Distance) {\n        cMass += pos;\n        cMassCount++;\n      }\n      if (distance(pos, vPos) < params.rule2Distance) {\n        colVel -= (pos - vPos);\n      }\n      if (distance(pos, vPos) < params.rule3Distance) {\n        cVel += vel;\n        cVelCount++;\n      }\n    }\n    if (cMassCount > 0) {\n      cMass = cMass / cMassCount - vPos;\n    }\n    if (cVelCount > 0) {\n      cVel = cVel / cVelCount;\n    }\n\n    vVel += cMass * params.rule1Scale + colVel * params.rule2Scale + cVel * params.rule3Scale;\n\n    // clamp velocity for a more pleasing simulation.\n    vVel = normalize(vVel) * clamp(length(vVel), 0.0, 0.1);\n\n    // kinematic update\n    vPos += vVel * params.deltaT;\n\n    // Wrap around boundary\n    if (vPos.x < -1.0) vPos.x = 1.0;\n    if (vPos.x > 1.0) vPos.x = -1.0;\n    if (vPos.y < -1.0) vPos.y = 1.0;\n    if (vPos.y > 1.0) vPos.y = -1.0;\n\n    particlesB.particles[index].pos = vPos;\n\n    // Write back\n    particlesB.particles[index].vel = vVel;\n  }",i=yield navigator.gpu.requestAdapter(),r=yield i.requestDevice(),s=yield Object(a.a)(),c=e.getContext("gpupresent").configureSwapChain({device:r,format:"bgra8unorm"}),l=r.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,type:"uniform-buffer"},{binding:1,visibility:GPUShaderStage.COMPUTE,type:"storage-buffer"},{binding:2,visibility:GPUShaderStage.COMPUTE,type:"storage-buffer"}]}),u=r.createPipelineLayout({bindGroupLayouts:[l]}),p=r.createRenderPipeline({layout:r.createPipelineLayout({bindGroupLayouts:[]}),vertexStage:{module:r.createShaderModule({code:s.compileGLSL(t,"vertex"),source:t,transform:e=>s.compileGLSL(e,"vertex")}),entryPoint:"main"},fragmentStage:{module:r.createShaderModule({code:s.compileGLSL(n,"fragment"),source:n,transform:e=>s.compileGLSL(e,"fragment")}),entryPoint:"main"},primitiveTopology:"triangle-list",depthStencilState:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus-stencil8"},vertexState:{vertexBuffers:[{arrayStride:16,stepMode:"instance",attributes:[{shaderLocation:0,offset:0,format:"float2"},{shaderLocation:1,offset:8,format:"float2"}]},{arrayStride:8,stepMode:"vertex",attributes:[{shaderLocation:2,offset:0,format:"float2"}]}]},colorStates:[{format:"bgra8unorm"}]}),f=r.createComputePipeline({layout:u,computeStage:{module:r.createShaderModule({code:s.compileGLSL(o,"compute"),source:o,transform:e=>s.compileGLSL(e,"compute")}),entryPoint:"main"}}),d={colorAttachments:[{attachment:void 0,loadValue:{r:0,g:0,b:0,a:1}}],depthStencilAttachment:{attachment:r.createTexture({size:{width:e.width,height:e.height,depth:1},format:"depth24plus-stencil8",usage:GPUTextureUsage.OUTPUT_ATTACHMENT}).createView(),depthLoadValue:1,depthStoreOp:"store",stencilLoadValue:0,stencilStoreOp:"store"}},v=new Float32Array([-.01,-.02,.01,-.02,0,.02]),[m,g]=r.createBufferMapped({size:v.byteLength,usage:GPUBufferUsage.VERTEX});new Float32Array(g).set(v),m.unmap();const h=new Float32Array([.04,.1,.025,.025,.02,.05,.005]),[y,P]=r.createBufferMapped({size:h.byteLength,usage:GPUBufferUsage.UNIFORM});new Float32Array(P).set(h),y.unmap();const b=new Float32Array(6e3);for(let e=0;e<1500;++e)b[4*e+0]=2*(Math.random()-.5),b[4*e+1]=2*(Math.random()-.5),b[4*e+2]=2*(Math.random()-.5)*.1,b[4*e+3]=2*(Math.random()-.5)*.1;const S=new Array(2),x=new Array(2);for(let e=0;e<2;++e){let t;[S[e],t]=r.createBufferMapped({size:b.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.STORAGE}),new Float32Array(t).set(b),S[e].unmap()}for(let e=0;e<2;++e)x[e]=r.createBindGroup({layout:l,entries:[{binding:0,resource:{buffer:y,offset:0,size:h.byteLength}},{binding:1,resource:{buffer:S[e],offset:0,size:b.byteLength}},{binding:2,resource:{buffer:S[(e+1)%2],offset:0,size:b.byteLength}}]});let V=0;return function(){d.colorAttachments[0].attachment=c.getCurrentTexture().createView();const e=r.createCommandEncoder({});{const t=e.beginComputePass();t.setPipeline(f),t.setBindGroup(0,x[V%2]),t.dispatch(1500),t.endPass()}{const t=e.beginRenderPass(d);t.setPipeline(p),t.setVertexBuffer(0,S[(V+1)%2]),t.setVertexBuffer(1,m),t.draw(3,1500,0,0),t.endPass()}r.defaultQueue.submit([e.finish()]),++V}}))}}}]);
//# sourceMappingURL=computeBoids-fdde9d.js.map